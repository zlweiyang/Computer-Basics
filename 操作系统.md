# 操作系统常见知识点 #

参考资料：

- 《操作系统》清华大学(向勇、陈渝) ，在线课程

- github：frank-lam/2019_campus_apply

# 一、操作系统的基本特征 #



# 二、进程与线程 #

<div align="center"> <img src="process-and-thread.png" width="450"/> </div><br>

## 1.进程 ##

**进程是资源分配的基本单位**，用来管理资源(例如：内存、文件、网络等资源)。

进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行的过程，包含正在运行的一个程序的所有状态信息，动态性，并发性，独立性以及制约性。

进程控制块(PCB)：进程标识信息，处理机现场保存，进程控制信息。**PCB是描述进程的数据结构。**

下图显示4个程序创建4个进程，这四个进程可以并发执行。

<div align="center"> <img src="process.png" width="450"/> </div><br>

进程的状态：创建，执行，等待，抢占，唤醒，结束。

## 2.线程 ##

**线程是独立调度的基本单位。**

线程是进程的一部分，描述指令流执行状态，它是进程中的指令执行流的最小单元，是CPU调度的基本单位，多个线程之间可以共享资源。

例：QQ和浏览器是两个进程，浏览器进程里面有很多线程，例如HTTP请求线程、渲染线程等等，线程的并发执行使得浏览器中点击一个新链接从而发起HTTP请求时，浏览器还可以响应用户的其它事件。

## 3进程和线程的区别 ##

**1. 拥有资源**：进程是资源分配的基本单位，线程不拥有资源，但可以访问线程隶属的进程资源。

**2. 调度：**线程是独立调度的基本单位，在同一进程中，线程之间的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。

**3.系统开销：**进程的创建和撤销，系统需要为之分配或回收资源，如内存空间、I/O设备等，其所付出的开销远大于创建或撤销线程时的开销。同样地，在进行进程切换时，需要对当前执行进程CPU环境的保存，以及对新调度进程CPU环境的设置，而线程切换时，只需要保存和设置少量寄存器内容，开销很小。

**4.通信方面**：进程间的通信需要进程同步和互斥手段的辅助，保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段(如全局变量)来进行通信。


## 2.线程的同步方式 ##

互斥：一个进程占用资源，其他进程不能使用。
死锁：多个进程各占用部分资源，形成循环等待。
饥饿：其他进程轮流占用资源，一个进程一直得不到资源。

1.互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不被多个线程同时访问。

2.信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用信号量对象。

3.事件(信号):通过通知操作的方式保持多线程同步，还可以方便的实现多线程的优先级的比较操作。即事件机制允许一个线程在处理完一个任务后，主动唤醒另一个线程执行任务。

## 3.进程的通信方式 ##

进程通信是进程进行同步的机制。

- 进程同步：控制多个进程按一定顺序执行。
- 进程通信：进程间传输信息。

**1.管道**

管道是通过调用pipe函数创建的，fd[0]用于读，fd[1]用于写。

    #include <unistd.h>
    int pipe(int fd[2]);

**限制条件：**

- 只支持半双工通信(单向交替传输)。
- 只能在父子进程中使用。

<div align="center"> <img src="message.png" width="450"/> </div><br>

**2.FIFO**

也称为命名管道，改善了管道只能在父子进程使用的限制。

    #include <sys/stat.h>
    int mkfifo(const char *path, mode_t mode);
    int mkfifoat(int fd, const char *path, mode_t mode);
FIFO常用于客户-服务器程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。

<div align="center"> <img src="mkfifo_mkfifoat.png" width="450"/> </div><br>

**3.消息队列**

相比于FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难；
- 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法。
- 读进程可以根据消息类型有选择的接收消息，而不像FIFO那样只能默认地接收。

**4.信号量**

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

**5.共享存储**

允许多个进程共享一个给定存储区。因为数据不需要在进程间复制，所以这是进程通信最快的一种方式。但是需要借助**4.信号量**用来同步对共享存储的访问。

多个进程可以使用同一个文件映射到它们的地址空间来实现共享内存。

**6.套接字**

可用于不同机器之间的进程通信。

**通信方式**

**间接通信**：通过内核进行通信。通过操作系统维护的**消息队列**实现进程间的消息接收和发送：1.每个消息队列都有一个唯一的标识，2.只有共享了相同的消息队列的进程才能通信。通信链路的属性：1.只有共享了**相同消息队列**的进程，才能建立连接。2.连接可以是单向或双向3.消息队列可以与多个进程相关联。4.每对进程可以共享多个消息队列。

间接通信的流程：1.创建一个新的消息队列，2.通过消息队列发送和接收消息3.销毁消息队列。

**直接通信**：线程之间通过共享信道进行通信。进程必须正确的命名对方，**通信链路的属性:**1.自动建立链路，2.一条链路恰好对应一对通信进程，3.每对进程之间只有一个链路存在，4.通信链路可以是单向也可以是双向的。

间接通信与直接通信的通信操作的区别是直接通信关注的是**接收和发送的进程**，而间接通信**关注的是消息队列**。

进程通信可以划分为阻塞和非阻塞通信，阻塞通信：1.阻塞发送：发送者在发送消息后进入等待，知道接受者成功接收 2.阻塞接收：接收者在请求接收消息后进入等待，直到成功收到一个消息。非阻塞通信：1.非阻塞发送：发送者在消息发送后，可立即进行其他操作。2.非阻塞接收:没有消息发送时，接收者在请求接收消息之后，接收不到任何消息。

通信链路缓冲：1.0容量：发送方必须等待接收方。2.有限容量：通信链路缓存队列满时，发送方必须等待。3.无限容量：发送方不需要等待。

**通信机制**

**1.信号**：进程间软件中断通知和处理机制。信号的接收处理：1.捕获，执行进程指定的信号处理函数别调用。2.忽略，执行操作系统指定的缺省处理。3.屏蔽：禁止进程接收和处理信号。确定：信息传输量小

**2.管道**:进程间基于内存文件的通信机制，子进程从父进程继承文件描述符，缺省文件描述符：0 stdin,1 stdout,2 stderr。
与管道相关的系统调用，读管道：read(fd,buffer,nbytes),scanf()是基于它实现的。写管道：write(fd,buffer,nbytes），printf()是基于它实现的。创建管道:pipe(rgfd)，rgfd是两个文件描述符组成的数组，rgfd[0]是读文件描述符。rgfd[1]是写文件描述符。

**3.消息队列：**消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制
1.每个消息是一个字节序列。
2.相同标识的消息组成按先进先出顺序组成一个消息队列。

**4.共享内存**
共享内存是把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制。
进程：1.每个进程都有私有内存地址空间。2，每个进程的内存地址空间需明确设置共享内存段。
线程：同一进程中的线程总是共享相同的内存地址空间。速度快，需要加**同步机制**。
## 4.进程有哪几种状态 ##

创建,执行，等待，抢占,唤醒，结束。

<div align="center"> <img src="ProcessState.jpg" width="450"/> </div><br>

三状态进程模型：运行状态，就绪状态，等待状态。辅佐状态：创建和退出

- 就绪状态(ready)：等待被调度。
- 运行状态(running):
- 阻塞状态(waiting):等待资源。

**注意一下几点：**

- 只有就绪状态和运行状态可以相互转换，其它都是单向转换。就绪状态的进程通过调度算法获得CPU时间，转为运行状态；而运行状态的进程，在分配给它CPU时间片用完之后就转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU资源时间，缺少CPU时间会从运行转换为就绪状态。
- 进程只能自己阻塞自己，因为只有进程自身才知道何时需要等待事件的发生。

## 5.进程调度策略 ##

## 1.批处理系统 ##

## 1.1先来先服务(FCFS) ##
按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须等待前面的长作业执行完毕才能执行而长作业又需要执行很长时间，造成了短作业等待时间过长。

## 1.2短作业(进程)优先调度算法 ##
按照估计运行时间最短的顺序进行调度。

这种算法可能会导致长作业饿死，处于一直等待短作业执行完毕的状态，因为如果一直有短作业到来，那么长作业永远得不到调度。

## 1.3 最短剩余时间优先 ##
按照剩余时间最短进行调度。

## 2.交互式系统 ##
## 2.1 时间片轮转 ##
将所有就绪进程按照FCFS原则排成一个队列，每次调度是，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时将CPU的时间分配给队首的进程。

**时间片轮转算法的效率和时间片的大小有很大关系：**

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小会导致进程切换太频繁。
- 如果时间片过长，那么实时性就得不到保障。

<div align="center"> <img src="processoftime.png" width="450"/> </div><br>

## 2.2 优先级调度算法 ##

为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远得不到调度，可以随着时间的推移增加等待进程的优先级。

## 2.3 多级反馈队列 ##

一个进程需要执行100个时间片，如果采用时间片轮转调度算法，那么需要交换100次。多级队列是为了这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1，2，4，8.。进程在第一个队列没执行完，就会被移动到下一个队列。这种方式下，之前的进程只需要交换7次。

每个队列优先权不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程，可以将这种调度算法看成**时间片轮转调度算法和优先级调度算法**的结合。

<div align="center"> <img src="mutilqueue.png" width="450"/> </div><br>

## 3.实时系统 ##

实时系统要求一个请求在一个确定时间内得到响应。
分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

# 三、死锁 #

## 6.什么是死锁？死锁产生的条件 ##
死锁是指由于**竞争资源**或者**通信关系**，两个或更多线程在执行中出现，永远相互**等待**只能有其他进程引发的事件。

<div align="center"> <img src="deadlock.png" width="450"/> </div><br>

死锁产生的条件：
1.互斥：任何时候只能有一个进程使用一个资源的实例,每个资源要么已经分配给了一个进程，要么就是可用的。
2.持有并等待：进程保持至少一个资源，并正在等待获取其他进程持有的资源
3.非抢占：资源只能在进程使用后自愿释放，不能被强制性抢占。
4.循环等待：存在等待进程集合，有两个或两个以上的进程组成一条死路，该环路中的每个进程都在等待下一个进程所占有的资源。。

## 7.死锁的基本策略和常用方法 ##
有应用进程处理死锁，操作系统则忽略死锁。
1.死锁预防：确保系统永远不会进入死锁状态。
2.死锁避免：在使用前进行判断，只允许不会出现死锁的进程请求资源。
银行家算法
3.死锁检测和恢复：在检测到运行系统进入死锁状态后，进行恢复。
死锁检测算法

# 四、内存管理 #

## 8.分页与分段的区别 ##

1.页是信息的物理单位，分页是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了更好的满足用户的需要。

2.页的大小固定且由系统决定；而段的长度却不固定，决定于用户所编写的程序。

3.分页的地址空间是一维的，程序员只需要利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的，程序员在标识一个地址时，既需要给出段名，又需要给出段内地址。

## 9.局部页面置换算法的比较

- LRU算法性能比较好，但系统开销较大
- FIFO算法系统开销较小，会出现Belady现象
- Clock算法是她们的折衷

页面访问时，不动态调整页面在链表中的顺序，仅做标记。

缺页时，再把它移动到链表末尾。

- 对于未被访问的页面，Clock和LRU算法的表现一样好
- 对于被访问的页面，Clock算法不能记录准确访问的顺序，而LRU算法可以。

## 10.全局置换算法

- 1.工作集置换算法
- 2.缺页率置换算法
- 3.抖动和负载控制

## 11.非连续内存分配 ##

段式存储管理(大)

页式存储管理(小)

页帧：把物理地址划分为大小相同的基本分配单位，2的N次方。

页面：把逻辑地址空间划分为大小相同的基本分配单位，帧和页的大小必须是相同的。

页面到页帧的转换：1.从逻辑地址到物理地址的转换 2.页表 3.MMU/TLB

# 五、设备管理 #

## 1.磁盘结构 ##



## 2.磁盘调度算法 ##

## 1.先来先服务 ##
> FCFS:First Come First Served

## 2.最短寻道时间优先 ##
> SSTF:Shortest Seek Time First

## 3.电梯算法 ##


# 六、链接 #

## 编译系统 ##

利用一个hello.c的程序说明

    #include <stdio.h>

    int main()
    {
       printf("hello, world\n");
       return 0;
    }

在Unix系统上，由编译器把源文件转化为目标文件。执行以下命令：

    gcc -o hello hello.c
其实际过程如下图所示：
<div align="center"> <img src="gcc.jpg" width="500"/> </div><br>

- 预处理阶段：处理以#开头的预处理命令，hello.c文件转化为hello.i文件；

        $ gcc -E hello.c -o hello.i

- 编译阶段：编译(ccl)器将文本文件翻译成汇编文件，hello.i文件转化为hello.s文件.它包含一个汇编语言程序；

        $ gcc -S hello.i -o hello.s

- 汇编阶段(as)：编译器(as)将hello.s翻译成机器码，将汇编文件转化为可重定向目标文件,hello.s文件转化为hello.o文件；

        $ as hello.s -o hello.o

- 链接阶段：printf函数是标准c库的一个函数，在printf.o这个单独单独编译好的目标文件中，连接器将重定向目标文件hello.o和printf.o合并，得到hello可执行目标文件。

        $ gcc hello.o -o hello